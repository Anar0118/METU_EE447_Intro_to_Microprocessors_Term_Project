#include "TM4C123GH6PM.h"
#include "screen.h"

// ---------------- GPIO pin mapping (Port A) ----------------
#define LCD_CE   (1<<3)   // PA3
#define LCD_DC   (1<<4)   // PA4
#define LCD_RST  (1<<6)   // PA6

static void delay_cycles(volatile uint32_t n) { while(n--) {} }

// SPI write one byte (SSI0)
static void ssi0_write(uint8_t data)
{
    while ((SSI0->SR & (1<<1)) == 0) {}    // TNF = bit1, wait TX FIFO not full
    SSI0->DR = data;
    while (SSI0->SR & (1<<4)) {}           // BSY = bit4, wait done
}

// Send command/data
static void lcd_cmd(uint8_t c)
{
    GPIOA->DATA &= ~LCD_DC;   // command
    GPIOA->DATA &= ~LCD_CE;   // CE low
    ssi0_write(c);
    GPIOA->DATA |= LCD_CE;    // CE high
}

static void lcd_data(uint8_t d)
{
    GPIOA->DATA |= LCD_DC;    // data
    GPIOA->DATA &= ~LCD_CE;   // CE low
    ssi0_write(d);
    GPIOA->DATA |= LCD_CE;    // CE high
}

static void lcd_gpio_init(void)
{
    SYSCTL->RCGCGPIO |= (1U<<0); // Port A clock
    __ASM("NOP"); __ASM("NOP"); __ASM("NOP");

    // PA3, PA4, PA6 as outputs
    GPIOA->DIR |= (LCD_CE | LCD_DC | LCD_RST);
    GPIOA->DEN |= (LCD_CE | LCD_DC | LCD_RST);

    // default states
    GPIOA->DATA |= LCD_CE;    // CE inactive high
    GPIOA->DATA |= LCD_DC;    // doesn't matter
}

static void ssi0_init(void)
{
    SYSCTL->RCGCSSI |= (1U<<0); // SSI0 clock
    __ASM("NOP"); __ASM("NOP"); __ASM("NOP");

    // Configure PA2=SSI0CLK, PA5=SSI0Tx
    GPIOA->AFSEL |= (1U<<2) | (1U<<5);
    GPIOA->PCTL  = (GPIOA->PCTL & ~((0xF<<8) | (0xF<<20))) | (2<<8) | (2<<20);
    GPIOA->DEN  |= (1U<<2) | (1U<<5);

    SSI0->CR1 = 0;                 // disable SSI during config
    SSI0->CC  = 0;                 // use system clock (default) or leave; OK on TM4C
    SSI0->CPSR = 10;               // prescaler (choose 10..254 even)
    // 8-bit, SPI mode 0 (CPOL=0, CPHA=0)
    SSI0->CR0 = (0x7) | (0<<6) | (0<<7);  // DSS=8-bit, SPO=0, SPH=0
    SSI0->CR1 |= (1U<<1);          // SSE enable
}

void lcd_init(void)
{
    lcd_gpio_init();
    ssi0_init();

    // Reset pulse
    GPIOA->DATA &= ~LCD_RST;
    delay_cycles(20000);
    GPIOA->DATA |= LCD_RST;
    delay_cycles(20000);

    // PCD8544 init sequence (common)
    lcd_cmd(0x21);  // extended instruction set
    lcd_cmd(0xA5);  // Vop (contrast) 0xA0..0xBF typical; tune if needed
    lcd_cmd(0x03);  // temperature coeff
    lcd_cmd(0x14);  // bias mode
    lcd_cmd(0x20);  // basic instruction set
    lcd_cmd(0x0C);  // normal display (0x0D inverse)

    lcd_clear();
}

// Set cursor
void lcd_set_xy(uint8_t x, uint8_t y)
{
    lcd_cmd(0x80 | x);  // X
    lcd_cmd(0x40 | y);  // Y (bank)
}

void lcd_clear(void)
{
    lcd_set_xy(0,0);
    for (int i=0; i<84*6; i++) lcd_data(0x00);
    lcd_set_xy(0,0);
}

// --- Minimal 5x7 font (you can expand later) ---
static const uint8_t font5x7[][5] = {
{0x00,0x00,0x00,0x00,0x00}, // space
{0x00,0x00,0x5F,0x00,0x00}, // !
{0x00,0x07,0x00,0x07,0x00}, // "
{0x14,0x7F,0x14,0x7F,0x14}, // #
{0x24,0x2A,0x7F,0x2A,0x12}, // $
{0x23,0x13,0x08,0x64,0x62}, // %
{0x36,0x49,0x55,0x22,0x50}, // &
{0x00,0x05,0x03,0x00,0x00}, // '
{0x00,0x1C,0x22,0x41,0x00}, // (
{0x00,0x41,0x22,0x1C,0x00}, // )
{0x14,0x08,0x3E,0x08,0x14}, // *
{0x08,0x08,0x3E,0x08,0x08}, // +
{0x00,0x50,0x30,0x00,0x00}, // ,
{0x08,0x08,0x08,0x08,0x08}, // -
{0x00,0x60,0x60,0x00,0x00}, // .
{0x20,0x10,0x08,0x04,0x02}, // /
{0x3E,0x51,0x49,0x45,0x3E}, // 0
{0x00,0x42,0x7F,0x40,0x00}, // 1
{0x42,0x61,0x51,0x49,0x46}, // 2
{0x21,0x41,0x45,0x4B,0x31}, // 3
{0x18,0x14,0x12,0x7F,0x10}, // 4
{0x27,0x45,0x45,0x45,0x39}, // 5
{0x3C,0x4A,0x49,0x49,0x30}, // 6
{0x01,0x71,0x09,0x05,0x03}, // 7
{0x36,0x49,0x49,0x49,0x36}, // 8
{0x06,0x49,0x49,0x29,0x1E}, // 9
{0x00,0x36,0x36,0x00,0x00}, // :
{0x00,0x56,0x36,0x00,0x00}, // ;
{0x08,0x14,0x22,0x41,0x00}, // <
{0x14,0x14,0x14,0x14,0x14}, // =
{0x00,0x41,0x22,0x14,0x08}, // >
{0x02,0x01,0x51,0x09,0x06}, // ?
{0x32,0x49,0x79,0x41,0x3E}, // @
{0x7E,0x11,0x11,0x11,0x7E}, // A
{0x7F,0x49,0x49,0x49,0x36}, // B
{0x3E,0x41,0x41,0x41,0x22}, // C
{0x7F,0x41,0x41,0x22,0x1C}, // D
{0x7F,0x49,0x49,0x49,0x41}, // E
{0x7F,0x09,0x09,0x09,0x01}, // F
{0x3E,0x41,0x49,0x49,0x7A}, // G
{0x7F,0x08,0x08,0x08,0x7F}, // H
{0x00,0x41,0x7F,0x41,0x00}, // I
{0x20,0x40,0x41,0x3F,0x01}, // J
{0x7F,0x08,0x14,0x22,0x41}, // K
{0x7F,0x40,0x40,0x40,0x40}, // L
{0x7F,0x02,0x04,0x02,0x7F}, // M
{0x7F,0x04,0x08,0x10,0x7F}, // N
{0x3E,0x41,0x41,0x41,0x3E}, // O
{0x7F,0x09,0x09,0x09,0x06}, // P
{0x3E,0x41,0x51,0x21,0x5E}, // Q
{0x7F,0x09,0x19,0x29,0x46}, // R
{0x46,0x49,0x49,0x49,0x31}, // S
{0x01,0x01,0x7F,0x01,0x01}, // T
{0x3F,0x40,0x40,0x40,0x3F}, // U
{0x1F,0x20,0x40,0x20,0x1F}, // V
{0x7F,0x20,0x18,0x20,0x7F}, // W
{0x63,0x14,0x08,0x14,0x63}, // X
{0x03,0x04,0x78,0x04,0x03}, // Y
{0x61,0x51,0x49,0x45,0x43}, // Z
};


void lcd_char(char c)
{
    if (c < 0x20 || c > 0x5A) c = '?';  // safety

    const uint8_t *glyph = font5x7[c - 0x20];

    for (int i = 0; i < 5; i++)
        lcd_data(glyph[i]);

    lcd_data(0x00); // space between chars
}

void lcd_print_uint(uint32_t v)
{
    char buf[11];
    int i = 0;

    if (v == 0) {
        lcd_char('0');
        return;
    }

    while (v && i < 10) {
        buf[i++] = '0' + (v % 10);
        v /= 10;
    }
    while (i--) lcd_char(buf[i]);
}

void lcd_print_amp(double a)
{
    uint32_t x = (uint32_t)(a * 100);  // 2 decimals

    lcd_print_uint(x / 100);
    lcd_char('.');
    lcd_char('0' + (x / 10) % 10);
    lcd_char('0' + x % 10);
}


void lcd_print(const char *s)
{
    while (*s) lcd_char(*s++);
}